# Heap
The heap is part of the system for dynamic allocation of memory.
This is because in order to use the stack, we need to know whether it will be 
used, and how much memory to reserve. Thus it cannot be used dynamically. \
A lot of programs, however, will need to deal with input of varying sizes, at
varying times. For this purpose we have the heap.

## Malloc
Malloc is the standard implementation of a dynamic allocator. It is part of the
standard C library, and is defined in the `stdlib.h` header. \
There are many great resources on how glibc's malloc works, but I am writing
this for myself....

Malloc provides at least two functions to manage dynamic memory:
```
malloc(size_t size);
free(void* ptr);
```
`malloc` will allocate new memory and return a pointer to this allocated memory,
for use by the program. \
`free` will free the memory so it can be resused and avoid leaking.

When malloc is first called it checks where the current program break is by 
calling `brk(NULL)`. It then sets up a new heap of some heuristically chosen 
size by calling `brk(a+size)` where a is the value returned by the first `brk`.


Ex:
```
brk(NULL)                               = 0x440000
brk(0x461000)                           = 0x461000
brk(NULL)                               = 0x461000
```
Now the internal heap size available to malloc is 0x21000 bytes.

The malloc implementation then manages this blob of memory using varios algorithms.
The main purposes of which are effeciency and speed. \
Should the program require more memory than servicable by the current heap size
malloc will expand it's heap by calling `brk` again.

Seen by the following program:

```
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define FLAG_SZ 0x2000
int main() {

    char* y = malloc(FLAG_SZ);
    for (int i = 0; i < 20; i++) {
        y = malloc(FLAG_SZ);
    }

}

brk(NULL)                               = 0x13c4000
brk(0x13e5000)                          = 0x13e5000
brk(NULL)                               = 0x13e5000
brk(NULL)                               = 0x13e5000
brk(0x1407000)                          = 0x1407000
```


### dlmalloc
This is the "original" malloc, written by Doug Lea.
It will provide the basis for most other malloc implementations later 
developed.

So malloc is in charge of managing the heap, it does this by splitting and
merging chunks. A chunk has the following struct in dlmalloc:
```
struct malloc_chunk {
  size_t               prev_foot;  /* Size of previous chunk (if free).  */
  size_t               head;       /* Size and inuse bits. */
  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;
};
```

Interestingly, as you can see, there is no struct field for the user data.
It is put into `fd` as these are only in use when the chunk is free, meaning
malloc can reclaim the space for metadata. So the pointer returned to the user
is `fd`.

The dlmalloc algorithm is defined to be
```
     Basic algorithm:
     If a small request (< 256 bytes minus per-chunk overhead):
       1. If one exists, use a remainderless chunk in associated smallbin.
          (Remainderless means that there are too few excess bytes to
          represent as a chunk.)
       2. If it is big enough, use the dv chunk, which is normally the
          chunk adjacent to the one used for the most recent small request.
       3. If one exists, split the smallest available chunk in a bin,
          saving remainder in dv.
       4. If it is big enough, use the top chunk.
       5. If available, get memory from system and use it
     Otherwise, for a large request:
       1. Find the smallest available binned chunk that fits, and use it
          if it is better fitting than dv chunk, splitting if necessary.
       2. If better fitting than any binned chunk, use the dv chunk.
       3. If it is big enough, use the top chunk.
       4. If request size >= mmap threshold, try to directly mmap this chunk.
       5. If available, get memory from system and use it

     The ugly goto's here ensure that postaction occurs along all paths.

```
